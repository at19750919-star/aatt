<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <title>理牌助手</title>
    <style>
        body { margin: 0; font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif; transition: background-color 0.3s ease; color: white; overflow: hidden; }
        #upload-container { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100vh; background-color: #121212; }
        #upload-label { padding: 20px 40px; border: 2px dashed #555; border-radius: 10px; cursor: pointer; font-size: 1.5em; transition: all 0.2s ease; }
        #upload-label:hover { background-color: #333; border-color: #888; }
        #file-input { display: none; }
        #loading-spinner { display: none; font-size: 2em; }
        #assistant-container { display: none; flex-direction: column; height: 100vh; width: 100vw; justify-content: center; align-items: center; padding: 20px; box-sizing: border-box; }
        #card-display { text-align: center; user-select: none; }
        #rank { font-size: 20vw; font-weight: bold; line-height: 1; }
        #suit { font-size: 15vw; line-height: 1; }
        #status, #message { font-size: 2em; text-shadow: 2px 2px 4px rgba(0,0,0,0.7); margin-top: 20px; }
        #controls { display: flex; flex-direction: column; align-items: center; gap: 15px; background-color: rgba(0, 0, 0, 0.3); padding: 20px; border-radius: 10px; margin-top: 30px; border: 1px solid rgba(255, 255, 255, 0.5); }
        .control-group { display: flex; align-items: center; gap: 10px; font-size: 1.2em; }
        #speed-slider { width: 200px; }
        #toggle-autoplay-btn { padding: 10px 20px; font-size: 1.2em; border: none; border-radius: 5px; color: white; cursor: pointer; transition: background-color 0.2s; background-color: #1a73e8; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
        #toggle-autoplay-btn:hover { filter: brightness(1.2); }
        .bg-red-card { background-color: #d93025; }
        .bg-blue-card { background-color: #1a73e8; }
        .font-red { color: #dc3545; }
        .font-black { color: #212529; }
    </style>
</head>
<body>
    <!-- 1. 上傳介面 -->
    <div id="upload-container">
        <label for="file-input" id="upload-label">點擊此處，選擇 Excel 檔案</label>
        <input type="file" id="file-input" accept=".xlsx">
        <div id="loading-spinner">處理中，請稍候...</div>
    </div>

    <!-- 2. 理牌助手介面 (所有東西都在這裡面) -->
    <div id="assistant-container">
        <div id="card-display">
            <div id="rank"></div>
            <div id="suit"></div>
        </div>
        <div id="status"></div>
        <div id="message"></div>
        <div id="controls">
            <div class="control-group">
                <label for="speed-slider">速度 (秒/張):</label>
                <input type="range" id="speed-slider" min="0.5" max="5" step="0.1" value="2.0">
                <span id="speed-value">2.0</span>
            </div>
            <button id="toggle-autoplay-btn">開始自動播放</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.3.0/exceljs.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function( ) {
            const fileInput = document.getElementById('file-input');
            const uploadContainer = document.getElementById('upload-container');
            const loadingSpinner = document.getElementById('loading-spinner');
            const assistantContainer = document.getElementById('assistant-container');
            const body = document.body;
            const rankDiv = document.getElementById('rank');
            const suitDiv = document.getElementById('suit');
            const statusDiv = document.getElementById('status');
            const messageDiv = document.getElementById('message');
            const speedSlider = document.getElementById('speed-slider');
            const speedValueSpan = document.getElementById('speed-value');
            const toggleAutoplayBtn = document.getElementById('toggle-autoplay-btn');
            let fullDeck = [];
            let currentIndex = -1;
            let autoplayTimer = null;
            let isAutoplaying = false;
            fileInput.addEventListener('change', handleFileSelect);
            document.addEventListener('keydown', handleKeyPress);
            speedSlider.addEventListener('input', handleSpeedChange);
            toggleAutoplayBtn.addEventListener('click', toggleAutoplay);
            async function handleFileSelect(event) {
                const file = event.target.files[0];
                if (!file) { return; }
                uploadContainer.style.display = 'none';
                loadingSpinner.style.display = 'block';
                try {
                    const deck = await parseExcelToDeck(file);
                    if (deck && deck.length > 0) {
                        startAssistant(deck);
                    } else {
                        throw new Error('無法從 Excel 中解析出任何有效的牌組資料。');
                    }
                } catch (error) {
                    console.error('解析 Excel 時發生錯誤:', error);
                    alert(`解析失敗：${error.message}`);
                    uploadContainer.style.display = 'block';
                    loadingSpinner.style.display = 'none';
                }
            }
            async function parseExcelToDeck(file) {
                const deck = [];
                const reader = new FileReader();
                await new Promise((resolve, reject) => {
                    reader.onload = async (e) => {
                        try {
                            const buffer = e.target.result;
                            const wb = new ExcelJS.Workbook();
                            await wb.xlsx.load(buffer);
                            const ws = wb.getWorksheet('Preview');
                            if (!ws) { throw new Error('找不到名為 "Preview" 的工作表。'); }
                            const COLS = 15, ROWS = 28;
                            for (let r = 1; r <= ROWS; r++) {
                                for (let c = 1; c <= COLS; c++) {
                                    const sheetColIndex = c + Math.floor((c - 1) / 5);
                                    const cell = ws.getCell(r, sheetColIndex);
                                    const value = cell.value ? String(cell.value) : '';
                                    const fill = cell.fill;
                                    let backColor = null;
                                    if (fill && fill.fgColor && fill.fgColor.argb) {
                                        if (fill.fgColor.argb.toUpperCase() === 'FFFFFF00') backColor = 'R';
                                        else if (fill.fgColor.argb.toUpperCase() === 'FF0080FF') backColor = 'B';
                                    }
                                    if (!value && !backColor) continue;
                                    const font = cell.font;
                                    let suit = '♠';
                                    if (font && font.color && font.color.argb) {
                                        if (font.color.argb.toUpperCase() === 'FFFF0000') suit = '♥';
                                    }
                                    let rank = value;
                                    if (value === '0') rank = 'K';
                                    if (value === '1') rank = 'A';
                                    deck.push({ rank, suit, back: backColor });
                                }
                            }
                            resolve();
                        } catch (err) { reject(err); }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
                return deck;
            }
            function startAssistant(deck) {
                fullDeck = deck;
                currentIndex = 0;
                loadingSpinner.style.display = 'none';
                uploadContainer.style.display = 'none';
                assistantContainer.style.display = 'flex';
                messageDiv.textContent = "按 [空白鍵] 或 [→] 手動下一張，或點擊下方按鈕開始自動播放";
                updateCardDisplay();
            }
            function updateCardDisplay() {
                if (currentIndex < 0 || currentIndex >= fullDeck.length) {
                    rankDiv.textContent = "完成";
                    suitDiv.textContent = "🎉";
                    statusDiv.textContent = `${fullDeck.length} / ${fullDeck.length}`;
                    body.className = '';
                    if (isAutoplaying) {
                        toggleAutoplay();
                    }
                    speak("全部排列完成，辛苦了！");
                    return;
                }
                const card = fullDeck[currentIndex];
                body.className = card.back === 'R' ? 'bg-red-card' : 'bg-blue-card';
                rankDiv.textContent = card.rank;
                suitDiv.textContent = card.suit;
                rankDiv.className = (card.suit === '♥' || card.suit === '♦') ? 'font-red' : 'font-black';
                suitDiv.className = (card.suit === '♥' || card.suit === '♦') ? 'font-red' : 'font-black';
                statusDiv.textContent = `${currentIndex + 1} / ${fullDeck.length}`;
                speakCard(card);
            }
            function handleKeyPress(event) {
                if (fullDeck.length === 0) return;
                if (isAutoplaying) {
                    toggleAutoplay();
                    return;
                }
                if (event.key === ' ' || event.key === 'ArrowRight') {
                    event.preventDefault();
                    advanceCard(1);
                } else if (event.key === 'ArrowLeft') {
                    event.preventDefault();
                    advanceCard(-1);
                }
            }
            function handleSpeedChange() {
                const speed = parseFloat(speedSlider.value).toFixed(1);
                speedValueSpan.textContent = speed;
                if (isAutoplaying) {
                    clearTimeout(autoplayTimer);
                    const interval = parseFloat(speedSlider.value) * 1000;
                    autoplayTimer = setTimeout(() => advanceCard(1, true), interval);
                }
            }
            function toggleAutoplay() {
                isAutoplaying = !isAutoplaying;
                if (isAutoplaying) {
                    toggleAutoplayBtn.textContent = '暫停播放';
                    toggleAutoplayBtn.style.backgroundColor = '#d93025';
                    messageDiv.textContent = "自動播放中... 按任意鍵可暫停";
                    const interval = parseFloat(speedSlider.value) * 1000;
                    autoplayTimer = setTimeout(() => advanceCard(1, true), interval);
                } else {
                    clearTimeout(autoplayTimer);
                    toggleAutoplayBtn.textContent = '繼續自動播放';
                    toggleAutoplayBtn.style.backgroundColor = '#1a73e8';
                    messageDiv.textContent = "已暫停。按 [空白鍵] 手動下一張，或點擊按鈕繼續播放";
                }
            }
            function advanceCard(direction, isFromAutoplay = false) {
                const newIndex = currentIndex + direction;
                if (newIndex >= 0 && newIndex <= fullDeck.length) {
                    currentIndex = newIndex;
                    updateCardDisplay();
                    if (isFromAutoplay && isAutoplaying && currentIndex < fullDeck.length) {
                        const interval = parseFloat(speedSlider.value) * 1000;
                        autoplayTimer = setTimeout(() => advanceCard(1, true), interval);
                    }
                }
            }
            function speakCard(card) {
                const backText = card.back === 'R' ? '紅底' : '藍底';
                const suitTextMap = { '♠': '黑桃', '♥': '紅心', '♦': '方塊', '♣': '梅花' };
                const suitText = suitTextMap[card.suit] || '';
                const rankText = card.rank;
                const textToSpeak = `${backText}，${suitText} ${rankText}`;
                speak(textToSpeak);
            }
            function speak(text) {
                window.speechSynthesis.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'zh-TW';
                utterance.rate = 1.1;
                utterance.pitch = 1.0;
                window.speechSynthesis.speak(utterance);
            }
        });
    </script>
</body>
</html>
